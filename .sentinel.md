# Sentinel: Heimdall Development Best Practices

> Evergreen principles learned from real bugs in the Heimdall Figma plugin + backend system.

---

## üîå Figma Plugin API: Node Traversal Budget

### The Exhaustion Problem

Figma plugins run single-threaded. The Figma API has a soft ceiling on how many node operations can be performed in a single execution cycle. After ~140+ node visits with heavy mutations (font loading, character writes, setRange calls), subsequent full-tree traversals will hang indefinitely ‚Äî no error, no timeout, just silence.

**Pattern: One traversal pass per page, not multiple**

```typescript
// ‚ùå BAD: Three separate full-tree passes on the same 140-node tree
await applyNodeMapping(contentRoot, mapping)   // Pass 1: ~140 visits + writes
await fillTextNodes(contentRoot, briefing)      // Pass 2: ~140 visits (HANGS)
await normalizeLayout(contentRoot)              // Pass 3: 6 phases √ó 140 = 840 visits

// ‚úÖ GOOD: Single content pass; skip redundant re-traversals
await applyNodeMapping(contentRoot, mapping)   // Handles all content + styling
// fillTextNodes skipped ‚Äî applyNodeMapping already covers all mapped fields
// normalizeLayout skipped ‚Äî styleFilledContent handles typography inline
```

**Why it matters:**
- `applyNodeMapping` already calls `loadFontsForTextNode`, `styleFilledContent`, and sets `textAutoResize` on each node it writes
- `fillTextNodes` is only needed for heimdallId-based fallback (legacy path without mapping)
- `normalizeLayout`'s 6-phase traversal (text fixes, auto-layout, hug content, stretch children, clipping, label styling) is 840+ additional visits that push past the API ceiling
- The hang is silent ‚Äî no error thrown, no timeout, no Figma crash. The plugin simply stops processing. This makes it extremely hard to debug without runtime instrumentation.

**Discovered:** 2026-02-12 via runtime log instrumentation showing `fillTextNodes` hanging at ~100 visits after `applyNodeMapping` completed 140 visits with writes. Confirmed by subsequent run where skipping `fillTextNodes` moved the hang to `normalizeLayout` (840+ additional visits).

---

### Figma Plugin: Dynamic Page Access

When the plugin manifest has `"documentAccess": "dynamic-page"`, pages and their children must be explicitly loaded before access.

```typescript
// ‚ùå BAD: Accessing children without loading (throws "Cannot access property children...")
const templatePage = figma.root.children.find(p => p.name === 'Template')
const children = templatePage.children  // ERROR

// ‚úÖ GOOD: Explicitly load page before accessing children
const templatePage = figma.root.children.find(p => p.name === 'Template')
await (templatePage as any).loadAsync()
const children = templatePage.children  // Works
```

**Why it matters:** The error message is clear, but the fix (`loadAsync`) isn't obvious from Figma's docs. This applies to both the source template page and the cloned target page.

---

### Figma Plugin: Inline UI Script Comments

The plugin UI runs from an inline HTML string. Single-line JavaScript comments (`//`) in the concatenated script will comment out everything after them on that line ‚Äî including subsequent code.

```typescript
// ‚ùå BAD: Single-line comments in inline script break subsequent code
var uiHtml = '...<script>'
  + 'function init() {'
  + '  // initialize handlers'   // THIS BREAKS EVERYTHING AFTER IT
  + '  setupButtons();'          // Never executes!
  + '}'

// ‚úÖ GOOD: Use block comments in inline scripts
var uiHtml = '...<script>'
  + 'function init() {'
  + '  /* initialize handlers */'
  + '  setupButtons();'
  + '}'
```

**Why it matters:** The concatenated string becomes one long line. A `//` comment on any segment comments out ALL subsequent segments. The UI loads but buttons don't work ‚Äî extremely confusing.

---

## üîÑ Job Queue Processing

### Sequential Jobs Must Be Independent

When processing multiple jobs in a loop, each job must complete or fail cleanly. A hang in one job blocks all subsequent jobs.

```typescript
// ‚ùå BAD: Hang in job 0 blocks jobs 1, 2, 3 forever
for (const job of jobs) {
  await processJob(job)  // If this hangs, loop never advances
}

// ‚úÖ GOOD: Each job is isolated with error handling
for (const job of jobs) {
  try {
    await processJob(job)
    results.push({ success: true, id: job.id })
  } catch (e) {
    results.push({ error: e.message, id: job.id })
    // Loop continues to next job
  }
}
```

**Why it matters:** In Figma's single-threaded environment, there's no native timeout mechanism. If an async operation hangs (not throws), try/catch won't help. The only defense is to avoid operations that can hang (see Node Traversal Budget above).

---

### Queue Deduplication

Monday.com items can be queued multiple times (manual re-queue, retry, etc.). Always check for duplicate idempotency keys before processing.

```typescript
// Pattern: Deduplicate by Monday item ID before processing
const seen = new Set<string>()
const uniqueJobs = jobs.filter(j => {
  const itemId = j.idempotencyKey.split(':')[1]
  if (seen.has(itemId)) return false
  seen.add(itemId)
  return true
})
```

**Why it matters:** Processing the same briefing 4 times (2 items √ó 2 duplicates) wastes Figma API budget and creates duplicate pages.

---

## üß™ Debugging Figma Plugins

### The Logging Challenge

Figma plugins can't use `console.log` from the main thread (only from the UI iframe). The main thread communicates via `figma.ui.postMessage`. For debugging, HTTP-based logging to a local server is the most effective approach.

**Pattern: Compact fetch-based instrumentation**

```typescript
// One-liner that works from both main thread and UI iframe
fetch('http://localhost:PORT/ingest',{
  method:'POST',
  headers:{'Content-Type':'application/json'},
  body:JSON.stringify({location:'file:line',message:'desc',data:{k:v},timestamp:Date.now()})
}).catch(()=>{});
```

**Key learnings from debugging this codebase:**
- Always log BEFORE and AFTER async operations to identify hangs vs errors
- Log entry/exit of recursive functions with visit counters
- Use thresholds (log first N visits) to avoid overwhelming the log
- Start thresholds conservatively, raise them when evidence shows the stall is past your visibility
- Tag logs with hypothesis IDs to correlate with your debugging theory

---

## üìã Quick Reference Checklist

Before modifying the Figma plugin:

### Node Operations
- [ ] After `applyNodeMapping`, do NOT add additional full-tree traversals
- [ ] Any new traversal function added to the post-fill pipeline will likely hang
- [ ] If you need post-fill processing, fold it into `applyNodeMapping` or `styleFilledContent`

### Template Pages
- [ ] `loadAsync()` called on template page before accessing children?
- [ ] `loadAsync()` called on cloned target page before processing?

### UI Script
- [ ] No single-line `//` comments in inline `uiHtml` string?
- [ ] Using `/* block comments */` instead?

### Job Processing
- [ ] Each job wrapped in try/catch?
- [ ] Queue deduplicated before processing?
- [ ] No operations that can hang silently inside the job loop?

### Backend
- [ ] CORS headers set for Figma plugin origin?
- [ ] API timeouts configured for external calls (Monday.com)?
- [ ] Job state transitions are atomic (queued ‚Üí processing ‚Üí complete/failed)?

---

*Principles learned from Heimdall Figma plugin debugging, 2026-02-12/13.*
